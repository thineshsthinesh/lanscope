<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lanscope Topology Scanner with Traffic Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: white;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #16213e;
            padding: 1rem 2rem;
            border-bottom: 2px solid #0f4c75;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h2 {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cumulative-badge {
            background: #e94560;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
        }

        .traffic-badge {
            background: #2ecc71;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            text-transform: uppercase;
            animation: trafficPulse 2s ease-in-out infinite;
        }

        @keyframes trafficPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        input {
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
            background: #0f3460;
            color: white;
            width: 200px;
        }

        input[type="file"] {
            display: none;
        }

        button {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .btn-primary { background: #e94560; color: white; }
        .btn-secondary { background: #0f4c75; color: white; }
        .btn-success { background: #2ecc71; color: white; }
        .btn-info { background: #17a2b8; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .btn-traffic { background: #9b59b6; color: white; }
        
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(233, 69, 96, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: calc(100vh - 70px);
        }

        .sidebar {
            background: #16213e;
            border-right: 2px solid #0f4c75;
            overflow-y: auto;
            padding: 1rem;
        }

        .topology-container {
            position: relative;
            background: #0f3460;
        }

        #topology-svg {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #0f3460 0%, #16213e 100%);
            cursor: grab;
        }

        #topology-svg.dragging {
            cursor: grabbing;
        }

        .stats {
            background: #1a1a2e;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            border-left: 3px solid #e94560;
        }

        .stats h4 {
            margin-bottom: 0.5rem;
            color: #e94560;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 0.3rem 0;
        }

        .stat-value {
            font-weight: bold;
            color: #4a90e2;
        }

        .traffic-stats {
            background: #1a1a2e;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            border-left: 3px solid #9b59b6;
        }

        .traffic-stats h4 {
            margin-bottom: 0.5rem;
            color: #9b59b6;
        }

        .traffic-control-section {
            background: #1a1a2e;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            border-left: 3px solid #2ecc71;
        }

        .traffic-control-section h4 {
            margin-bottom: 0.5rem;
            color: #2ecc71;
        }

        .export-import-section {
            background: #1a1a2e;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            border-left: 3px solid #2ecc71;
        }

        .export-import-section h4 {
            margin-bottom: 0.5rem;
            color: #2ecc71;
        }

        .export-import-controls {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .export-controls, .import-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.8rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: auto;
        }

        .scan-history {
            background: #1a1a2e;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
        }

        .scan-history h4 {
            margin-bottom: 0.5rem;
            color: #f39c12;
        }

        .history-item {
            background: #0f3460;
            margin: 0.3rem 0;
            padding: 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
        }

        .history-network { color: #e94560; font-weight: bold; }
        .history-stats { color: #ccc; }
        .history-time { color: #999; font-size: 0.7rem; }

        .host-item {
            background: #1a1a2e;
            margin: 0.5rem 0;
            padding: 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .host-item.new-host {
            border-left: 3px solid #2ecc71;
            animation: newHostPulse 2s ease-in-out;
        }

        .host-item.existing-host {
            border-left: 3px solid #4a90e2;
        }

        .host-item.inactive-host {
            border-left: 3px solid #666;
            opacity: 0.6;
        }

        .host-item:hover {
            background: #0f4c75;
            transform: translateX(5px);
        }

        .host-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .host-ip { font-weight: bold; color: #e94560; }
        .host-name { color: #ccc; font-size: 0.9rem; }
        .host-type { color: #4a90e2; font-size: 0.8rem; text-transform: uppercase; }
        .host-hops { color: #f39c12; font-size: 0.8rem; }

        .host-badges {
            display: flex;
            gap: 0.3rem;
            margin-top: 0.3rem;
        }

        .badge {
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            font-weight: bold;
        }

        .badge.new { background: #2ecc71; color: white; }
        .badge.scan-count { background: #f39c12; color: white; }
        .badge.current { background: #e94560; color: white; }

        @keyframes newHostPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); }
            50% { box-shadow: 0 0 0 10px rgba(46, 204, 113, 0); }
        }

        .node { cursor: pointer; }
        .node circle { stroke: #fff; stroke-width: 2px; }
        
        .node.new-discovery circle {
            stroke: #2ecc71;
            stroke-width: 4px;
            animation: newNodePulse 3s ease-in-out infinite;
        }

        .node.current-scan circle {
            stroke: #e94560;
            stroke-width: 3px;
        }

        .node.inactive-host circle {
            stroke: #666;
            stroke-width: 2px;
            stroke-dasharray: 4,2;
        }

        .node.dragging circle {
            stroke: #fff;
            stroke-width: 4px;
        }

        @keyframes newNodePulse {
            0%, 100% { stroke-opacity: 1; }
            50% { stroke-opacity: 0.3; }
        }
        
        .link {
            stroke: #4a90e2;
            stroke-opacity: 0.6;
            stroke-width: 2;
            fill: none;
        }

        .link.internet_path {
            stroke: #e94560;
            stroke-width: 3;
            stroke-dasharray: 8,4;
            animation: dash 3s linear infinite;
        }

        .link.traced_path {
            stroke: #f39c12;
            stroke-width: 2.5;
            stroke-dasharray: 6,3;
        }

        .link.direct {
            stroke: #2ecc71;
            stroke-width: 2;
        }

        .link.current-scan {
            stroke-opacity: 1;
            filter: drop-shadow(0 0 3px currentColor);
        }

        @keyframes dash {
            to { stroke-dashoffset: -12; }
        }

        /* Traffic Particle Styles */
        .traffic-particle {
            pointer-events: none;
        }

        .traffic-particle.TCP {
            fill: #3498db;
            stroke: #2980b9;
            stroke-width: 1;
        }

        .traffic-particle.UDP {
            fill: #e74c3c;
            stroke: #c0392b;
            stroke-width: 1;
        }

        .traffic-particle.ICMP {
            fill: #f39c12;
            stroke: #d68910;
            stroke-width: 1;
        }

        .traffic-particle.HTTP, .traffic-particle.HTTPS {
            fill: #2ecc71;
            stroke: #27ae60;
            stroke-width: 1;
        }

        .traffic-particle.DNS {
            fill: #9b59b6;
            stroke: #8e44ad;
            stroke-width: 1;
        }

        .node-label {
            fill: white;
            font-size: 11px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
        }

        .hop-label {
            fill: #f39c12;
            font-size: 9px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: bold;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            pointer-events: none;
            opacity: 0;
            font-size: 12px;
            z-index: 1000;
            border: 1px solid #e94560;
            max-width: 280px;
            line-height: 1.4;
        }

        .tooltip-header {
            font-weight: bold;
            color: #e94560;
            margin-bottom: 0.5rem;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 0.2rem 0;
        }

        .tooltip-label { color: #ccc; }
        .tooltip-value { color: white; font-weight: 500; }

        .progress {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            text-align: center;
            z-index: 100;
            background: rgba(0,0,0,0.95);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 2px solid #e94560;
            min-width: 200px;
            box-shadow: 0 4px 20px rgba(233, 69, 96, 0.3);
        }

        .spinner {
            width: 30px;
            height: 30px;
            border: 3px solid #16213e;
            border-top: 3px solid #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status { 
            position: absolute; 
            bottom: 1rem; 
            left: 1rem; 
            background: rgba(0,0,0,0.9); 
            padding: 0.5rem 1rem; 
            border-radius: 6px;
            font-size: 0.9rem;
            max-width: 400px;
            border-left: 3px solid #e94560;
        }

        .zoom-controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 10;
        }

        .zoom-controls button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(0,0,0,0.95);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            border: 1px solid #0f4c75;
            max-height: 60vh;
            overflow-y: auto;
        }

        .legend h4 {
            color: #e94560;
            margin-bottom: 0.5rem;
        }

        .legend-section {
            margin-bottom: 1rem;
        }

        .legend-section:last-child {
            margin-bottom: 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 0.3rem 0;
        }

        .legend-line {
            width: 30px;
            height: 2px;
            margin-right: 10px;
        }

        .legend-line.internet { background: #e94560; }
        .legend-line.traced { background: #f39c12; }
        .legend-line.direct { background: #2ecc71; }

        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid;
        }

        .legend-circle.new { border-color: #2ecc71; background: #2ecc71; }
        .legend-circle.current { border-color: #e94560; background: #e94560; }
        .legend-circle.inactive { border-color: #666; background: none; }

        .legend-circle.TCP { background: #3498db; border-color: #3498db; }
        .legend-circle.UDP { background: #e74c3c; border-color: #e74c3c; }
        .legend-circle.ICMP { background: #f39c12; border-color: #f39c12; }
        .legend-circle.HTTP { background: #2ecc71; border-color: #2ecc71; }
        .legend-circle.DNS { background: #9b59b6; border-color: #9b59b6; }

        .scan-summary {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #2ecc71;
            min-width: 250px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .scan-summary.show {
            opacity: 1;
        }

        .summary-title {
            color: #2ecc71;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .clear-data-section {
            background: #1a1a2e;
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 6px;
            border-left: 3px solid #dc3545;
        }

        .clear-data-section h4 {
            color: #dc3545;
            margin-bottom: 0.5rem;
        }

        .clear-data-section p {
            font-size: 0.8rem;
            color: #ccc;
            margin-bottom: 0.5rem;
        }

        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(0,0,0,0.95);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid #2ecc71;
            max-width: 350px;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
        }

        .notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .notification.error {
            border-left-color: #dc3545;
        }

        .notification.warning {
            border-left-color: #f39c12;
        }

        .notification.info {
            border-left-color: #17a2b8;
        }
    </style>
</head>
<body>
    <div class="header">
        <h2>
            Network Topology Scanner 
            <span class="cumulative-badge">Cumulative</span>
            <span class="traffic-badge" id="traffic-badge" style="display: none;">Live Traffic</span>
        </h2>
        <div class="controls">
            <input type="text" id="network-input" placeholder="192.168.1.0/24" value="192.168.1.0/24">
            <button class="btn-primary" id="scan-btn" onclick="toggleScan()">Start Scan</button>
            <button class="btn-traffic" id="traffic-btn" onclick="toggleTraffic()">Start Traffic Capture</button>
            <button class="btn-secondary" onclick="resetView()">Reset View</button>
        </div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="stats" id="stats">
                <h4>Cumulative Statistics</h4>
                <div class="stat-grid">
                    <div class="stat-item">
                        <span>Total Hosts:</span>
                        <span class="stat-value" id="cumulative-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Current Scan:</span>
                        <span class="stat-value" id="current-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span>New Found:</span>
                        <span class="stat-value" id="new-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Max Hops:</span>
                        <span class="stat-value" id="max-hops">-</span>
                    </div>
                </div>
                <div class="stat-item">
                    <span>Network:</span>
                    <span class="stat-value" id="network-info">-</span>
                </div>
                <div class="stat-item">
                    <span>Status:</span>
                    <span class="stat-value" id="scan-status">Ready</span>
                </div>
            </div>

            <div class="traffic-control-section">
                <h4>Traffic Visualization</h4>
                <p style="font-size: 0.8rem; color: #ccc; margin-bottom: 0.5rem;">
                    Capture and visualize network packets in real-time
                </p>
                <button class="btn-traffic" id="traffic-control-btn" onclick="toggleTraffic()">
                    Start Traffic Capture
                </button>
            </div>

            <div class="traffic-stats" id="traffic-stats" style="display: none;">
                <h4>Traffic Statistics</h4>
                <div class="stat-grid">
                    <div class="stat-item">
                        <span>Packets:</span>
                        <span class="stat-value" id="packet-count">0</span>
                    </div>
                    <div class="stat-item">
                        <span>Rate:</span>
                        <span class="stat-value" id="packet-rate">0/s</span>
                    </div>
                </div>
                <div class="stat-item">
                    <span>TCP:</span>
                    <span class="stat-value" id="tcp-count">0</span>
                </div>
                <div class="stat-item">
                    <span>UDP:</span>
                    <span class="stat-value" id="udp-count">0</span>
                </div>
                <div class="stat-item">
                    <span>ICMP:</span>
                    <span class="stat-value" id="icmp-count">0</span>
                </div>
                <div class="stat-item">
                    <span>Other:</span>
                    <span class="stat-value" id="other-count">0</span>
                </div>
            </div>

            <div class="export-import-section">
                <h4>Export / Import Data</h4>
                <div class="export-import-controls">
                    <div class="export-controls">
                        <button class="btn-success" onclick="exportData()">Export</button>
                        <div class="checkbox-group">
                            <input type="checkbox" id="include-positions" checked>
                            <label for="include-positions">Include positions</label>
                        </div>
                    </div>
                    <div class="import-controls">
                        <button class="btn-info" onclick="importData()">Import</button>
                        <input type="file" id="import-file" accept=".json" onchange="handleFileImport(event)">
                        <div class="checkbox-group">
                            <input type="checkbox" id="merge-mode" checked>
                            <label for="merge-mode">Merge with existing</label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="scan-history">
                <h4>Scan History</h4>
                <div id="history-list">
                    <div style="color: #666; text-align: center; padding: 1rem;">
                        No scans yet
                    </div>
                </div>
            </div>
            
            <div>
                <h4>Discovered Hosts</h4>
                <div id="hosts-list">
                    <div style="color: #666; text-align: center; padding: 2rem;">
                        No hosts found yet
                    </div>
                </div>
            </div>

            <div class="clear-data-section">
                <h4>Reset Data</h4>
                <p>Clear all cumulative scan data and start fresh.</p>
                <button class="btn-danger" onclick="clearCumulativeData()">Clear All Data</button>
            </div>
        </div>

        <div class="topology-container">
            <svg id="topology-svg"></svg>
            
            <div class="zoom-controls">
                <button class="btn-secondary" onclick="zoomIn()" title="Zoom In">+</button>
                <button class="btn-secondary" onclick="zoomOut()" title="Zoom Out">âˆ’</button>
                <button class="btn-secondary" onclick="zoomReset()" title="Reset Zoom">âŒ‚</button>
            </div>
            
            <div class="legend">
                <h4>Legend</h4>
                
                <div class="legend-section">
                    <strong>Connections</strong>
                    <div class="legend-item">
                        <div class="legend-line internet"></div>
                        <span>Internet Path</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line traced"></div>
                        <span>Traced Route</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-line direct"></div>
                        <span>Direct Connection</span>
                    </div>
                </div>

                <div class="legend-section">
                    <strong>Host Status</strong>
                    <div class="legend-item">
                        <div class="legend-circle new"></div>
                        <span>New Discovery</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle current"></div>
                        <span>Current Scan</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle inactive"></div>
                        <span>Previous Scan</span>
                    </div>
                </div>

                <div class="legend-section" id="traffic-legend" style="display: none;">
                    <strong>Traffic Types</strong>
                    <div class="legend-item">
                        <div class="legend-circle TCP"></div>
                        <span>TCP</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle UDP"></div>
                        <span>UDP</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle ICMP"></div>
                        <span>ICMP</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle HTTP"></div>
                        <span>HTTP/HTTPS</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-circle DNS"></div>
                        <span>DNS</span>
                    </div>
                </div>
                
                <div class="legend-section">
                    <strong>Controls</strong>
                    <div style="font-size: 0.7rem; color: #ccc;">
                        â€¢ Drag nodes to reposition<br>
                        â€¢ Mouse wheel to zoom<br>
                        â€¢ Drag background to pan<br>
                        â€¢ Click host in sidebar to focus
                    </div>
                </div>
            </div>
            
            <div class="progress" id="progress" style="display: none;">
                <div class="spinner"></div>
                <div>Scanning Network...</div>
                <div id="progress-text">0%</div>
            </div>

            <div class="scan-summary" id="scan-summary">
                <div class="summary-title">Scan Complete!</div>
                <div id="summary-content"></div>
            </div>
            
            <div class="status" id="status-bar">
                Ready for cumulative scanning - Previous discoveries will be preserved and merged with new findings
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>
    <div class="notification" id="notification"></div>

    <script>
        let socket;
        let isScanning = false;
        let isTrafficCapturing = false;
        let hosts = new Map();
        let cumulativeHosts = new Map();
        let topology = { nodes: [], links: [] };
        let simulation;
        let scanHistory = [];
        let zoom;
        let svg;
        let g;
        let trafficParticlesGroup;
        
        // Traffic statistics
        let trafficStats = {
            total: 0,
            TCP: 0,
            UDP: 0,
            ICMP: 0,
            HTTP: 0,
            HTTPS: 0,
            DNS: 0,
            other: 0,
            lastSecond: 0,
            lastUpdate: Date.now()
        };

        // Connect to backend
        function initConnection() {
            socket = io();
            
            socket.on('connect', () => {
                updateStatus('Connected to cumulative scanner');
            });

            socket.on('cumulative_loaded', (data) => {
                updateStatus(`Loaded ${data.total_hosts} hosts from previous scans`);
                scanHistory = data.scan_history || [];
                updateScanHistory();
                updateStats();
            });

            socket.on('scan_started', (data) => {
                isScanning = true;
                updateScanButton();
                showProgress(true);
                updateStatus(`Cumulative scan started: ${data.target}...`);
                document.getElementById('network-info').textContent = data.target;
                
                document.getElementById('current-count').textContent = '0';
                document.getElementById('new-count').textContent = '0';
            });

            socket.on('scan_status', (data) => {
                updateStatus(data.message);
            });

            socket.on('host_found', (data) => {
                const status = data.new ? 'NEW' : 'EXISTING';
                const statusColor = data.new ? '#2ecc71' : '#4a90e2';
                updateStatus(`<span style="color: ${statusColor}">${status}</span>: ${data.ip} (${data.rtt.toFixed(1)}ms)`);
            });

            socket.on('scan_progress', (data) => {
                document.getElementById('progress-text').textContent = `${data.progress.toFixed(1)}%`;
            });

            socket.on('host_analyzed', (data) => {
                hosts.set(data.ip, data);
                cumulativeHosts.set(data.ip, data);
                updateHostsList();
                updateStats();
            });

            socket.on('cumulative_topology_ready', (data) => {
                topology = data;
                drawCumulativeTopology();
                showProgress(false);
                isScanning = false;
                updateScanButton();
                updateStatus('Cumulative topology updated - All discoveries preserved');
                updateStats();
            });

            socket.on('scan_summary', (data) => {
                showScanSummary(data);
                scanHistory.unshift({
                    network: document.getElementById('network-input').value,
                    hosts_found: data.total_hosts_found,
                    new_hosts: data.new_hosts,
                    time: new Date().toLocaleString()
                });
                updateScanHistory();
            });

            socket.on('scan_stopped', () => {
                isScanning = false;
                updateScanButton();
                showProgress(false);
                updateStatus('Scan stopped - Cumulative data preserved');
            });

            socket.on('cumulative_cleared', (data) => {
                cumulativeHosts.clear();
                hosts.clear();
                topology = { nodes: [], links: [] };
                scanHistory = [];
                clearTopology();
                updateHostsList();
                updateScanHistory();
                updateStats();
                updateStatus('All cumulative data cleared - Starting fresh');
            });

            // Traffic capture events
            socket.on('traffic_capture_started', (data) => {
                isTrafficCapturing = true;
                updateTrafficButton();
                document.getElementById('traffic-badge').style.display = 'inline-block';
                document.getElementById('traffic-stats').style.display = 'block';
                document.getElementById('traffic-legend').style.display = 'block';
                showNotification('Traffic capture started', 'success');
                updateStatus('Traffic capture active - Visualizing network packets');
            });

            socket.on('traffic_capture_stopped', (data) => {
                isTrafficCapturing = false;
                updateTrafficButton();
                document.getElementById('traffic-badge').style.display = 'none';
                showNotification('Traffic capture stopped', 'info');
                updateStatus('Traffic capture stopped');
            });

            socket.on('traffic_packet', (data) => {
                animateTrafficPacket(data);
                updateTrafficStats(data.protocol);
            });
        }

        function toggleScan() {
            if (isScanning) {
                socket.emit('stop_scan');
            } else {
                const network = document.getElementById('network-input').value;
                if (network) {
                    hosts.clear();
                    socket.emit('start_scan', { target: network });
                }
            }
        }

        function toggleTraffic() {
            if (isTrafficCapturing) {
                socket.emit('stop_traffic_capture');
            } else {
                socket.emit('start_traffic_capture');
            }
        }

        function updateTrafficButton() {
            const btn = document.getElementById('traffic-btn');
            const ctrlBtn = document.getElementById('traffic-control-btn');
            const text = isTrafficCapturing ? 'Stop Traffic Capture' : 'Start Traffic Capture';
            const className = isTrafficCapturing ? 'btn-danger' : 'btn-traffic';
            
            btn.textContent = text;
            btn.className = className;
            ctrlBtn.textContent = text;
            ctrlBtn.className = className;
        }

        function updateTrafficStats(protocol) {
            trafficStats.total++;
            trafficStats.lastSecond++;
            
            if (trafficStats[protocol]) {
                trafficStats[protocol]++;
            } else {
                trafficStats.other++;
            }
            
            // Update display
            document.getElementById('packet-count').textContent = trafficStats.total;
            document.getElementById('tcp-count').textContent = trafficStats.TCP;
            document.getElementById('udp-count').textContent = trafficStats.UDP;
            document.getElementById('icmp-count').textContent = trafficStats.ICMP;
            document.getElementById('other-count').textContent = trafficStats.other + trafficStats.HTTP + trafficStats.HTTPS + trafficStats.DNS;
            
            // Calculate rate every second
            const now = Date.now();
            if (now - trafficStats.lastUpdate >= 1000) {
                document.getElementById('packet-rate').textContent = trafficStats.lastSecond + '/s';
                trafficStats.lastSecond = 0;
                trafficStats.lastUpdate = now;
            }
        }

        function animateTrafficPacket(packetData) {
            if (!g || !trafficParticlesGroup) return;
            
            // Find source and target nodes
            const sourceNode = topology.nodes.find(n => n.ip === packetData.source);
            const targetNode = topology.nodes.find(n => n.ip === packetData.target);
            
            if (!sourceNode || !targetNode) return;
            
            // Create particle
            const particle = trafficParticlesGroup.append('circle')
                .attr('class', `traffic-particle ${packetData.protocol}`)
                .attr('r', Math.min(3 + packetData.size / 200, 8))
                .attr('cx', sourceNode.x)
                .attr('cy', sourceNode.y);
            
            // Animate particle along the path
            particle.transition()
                .duration(1000)
                .ease(d3.easeLinear)
                .attr('cx', targetNode.x)
                .attr('cy', targetNode.y)
                .on('end', function() {
                    d3.select(this).remove();
                });
        }

        function clearCumulativeData() {
            if (confirm('Are you sure you want to clear ALL cumulative scan data? This cannot be undone.')) {
                socket.emit('clear_cumulative');
            }
        }

        // Export/Import functions
        function exportData() {
            const includePositions = document.getElementById('include-positions').checked;
            const url = `/export?positions=${includePositions}`;
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `network_topology_export_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showNotification('Export started - Check your downloads folder', 'info');
        }

        function importData() {
            document.getElementById('import-file').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.toLowerCase().endsWith('.json')) {
                showNotification('Please select a JSON file', 'error');
                return;
            }

            const formData = new FormData();
            formData.append('file', file);
            formData.append('merge', document.getElementById('merge-mode').checked);

            fetch('/import', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showNotification(data.message, 'success');
                    setTimeout(() => {
                        location.reload();
                    }, 2000);
                } else {
                    showNotification(`Import failed: ${data.error}`, 'error');
                }
            })
            .catch(error => {
                showNotification(`Import error: ${error.message}`, 'error');
            });

            event.target.value = '';
        }

        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 5000);
        }

        // Zoom functions
        function zoomIn() {
            zoom.scaleBy(svg, 1.5);
        }

        function zoomOut() {
            zoom.scaleBy(svg, 1 / 1.5);
        }

        function zoomReset() {
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity
            );
        }

        function updateScanButton() {
            const btn = document.getElementById('scan-btn');
            btn.textContent = isScanning ? 'Stop Scan' : 'Start Scan';
            btn.className = isScanning ? 'btn-secondary' : 'btn-primary';
            btn.disabled = false;
        }

        function showProgress(show) {
            document.getElementById('progress').style.display = show ? 'block' : 'none';
        }

        function showScanSummary(data) {
            const summary = document.getElementById('scan-summary');
            const content = document.getElementById('summary-content');
            
            content.innerHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Hosts Found:</span>
                    <span class="tooltip-value">${data.total_hosts_found}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">New Discoveries:</span>
                    <span class="tooltip-value" style="color: #2ecc71">${data.new_hosts}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Previously Known:</span>
                    <span class="tooltip-value">${data.existing_hosts}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Total Database:</span>
                    <span class="tooltip-value" style="color: #e94560">${data.cumulative_total}</span>
                </div>
            `;
            
            summary.classList.add('show');
            setTimeout(() => {
                summary.classList.remove('show');
            }, 8000);
        }

        function updateStatus(message) {
            document.getElementById('status-bar').innerHTML = message;
            document.getElementById('scan-status').textContent = isScanning ? 'Scanning...' : 'Ready';
        }

        function updateStats() {
            document.getElementById('cumulative-count').textContent = cumulativeHosts.size;
            document.getElementById('current-count').textContent = hosts.size;
            
            let newCount = 0;
            hosts.forEach(host => {
                if (host.new) newCount++;
            });
            document.getElementById('new-count').textContent = newCount;
            
            let maxHops = 0;
            if (topology.nodes.length > 0) {
                maxHops = Math.max(...topology.nodes.map(n => n.hop_distance || 0));
                document.getElementById('max-hops').textContent = maxHops;
            } else {
                document.getElementById('max-hops').textContent = '-';
            }
        }

        function updateScanHistory() {
            const container = document.getElementById('history-list');
            
            if (scanHistory.length === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center; padding: 1rem;">No scans yet</div>';
                return;
            }

            let html = '';
            scanHistory.slice(0, 5).forEach(scan => {
                html += `
                    <div class="history-item">
                        <div class="history-network">${scan.network}</div>
                        <div class="history-stats">
                            ${scan.hosts_found} hosts found
                            ${scan.new_hosts ? `(${scan.new_hosts} new)` : ''}
                        </div>
                        <div class="history-time">${scan.time || scan.start_time}</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function updateHostsList() {
            const container = document.getElementById('hosts-list');
            
            if (cumulativeHosts.size === 0) {
                container.innerHTML = '<div style="color: #666; text-align: center; padding: 2rem;">No hosts found yet</div>';
                return;
            }

            let sortedHosts = Array.from(cumulativeHosts.entries());
            
            const hopDistances = new Map();
            if (topology.nodes.length > 0) {
                topology.nodes.forEach(node => {
                    if (node.hop_distance !== undefined) {
                        hopDistances.set(node.ip, node.hop_distance);
                    }
                });
                
                sortedHosts.sort((a, b) => {
                    const hostA = a[1];
                    const hostB = b[1];
                    
                    if (hostA.new && !hostB.new) return -1;
                    if (!hostA.new && hostB.new) return 1;
                    
                    const inCurrentA = hosts.has(a[0]);
                    const inCurrentB = hosts.has(b[0]);
                    if (inCurrentA && !inCurrentB) return -1;
                    if (!inCurrentA && inCurrentB) return 1;
                    
                    const hopsA = hopDistances.get(a[0]) || 1;
                    const hopsB = hopDistances.get(b[0]) || 1;
                    return hopsA - hopsB;
                });
            }

            let html = '';
            sortedHosts.forEach(([ip, host]) => {
                const deviceIcon = getDeviceIcon(host.device_type);
                const hops = hopDistances.get(ip) || 1;
                const inCurrentScan = hosts.has(ip);
                
                let hostClass = 'host-item';
                if (host.new) hostClass += ' new-host';
                else if (inCurrentScan) hostClass += ' existing-host';
                else hostClass += ' inactive-host';
                
                html += `
                    <div class="${hostClass}" onclick="focusHost('${ip}')">
                        <div class="host-header">
                            <div>
                                <div class="host-ip">${deviceIcon} ${ip}</div>
                                <div class="host-name">${host.hostname}</div>
                            </div>
                        </div>
                        <div class="host-type">${host.device_type}</div>
                        <div class="host-hops">${hops} hop${hops > 1 ? 's' : ''}</div>
                        <div class="host-badges">
                            ${host.new ? '<span class="badge new">NEW</span>' : ''}
                            ${inCurrentScan ? '<span class="badge current">CURRENT</span>' : ''}
                            <span class="badge scan-count">Ã—${host.scan_count || 1}</span>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function getDeviceIcon(type) {
            const icons = {
                'router': 'ðŸŒ',
                'gateway': 'ðŸšª', 
                'switch': 'ðŸ”€',
                'ap': 'ðŸ“¡',
                'host': 'ðŸ’»',
                'local_machine': 'ðŸ–¥ï¸',
                'intermediate': 'ðŸ“¶',
                'wildcard': 'â“',
                'internet': 'ðŸŒ'
            };
            return icons[type] || 'ðŸ’»';
        }

        function drawCumulativeTopology() {
            svg = d3.select("#topology-svg");
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;
            
            svg.selectAll("*").remove();

            if (topology.nodes.length === 0) return;

            zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on("zoom", function(event) {
                    g.attr("transform", event.transform);
                });

            svg.call(zoom);

            g = svg.append("g");

            // Create traffic particles group (on top layer)
            trafficParticlesGroup = g.append("g").attr("class", "traffic-particles");

            const centerX = width / 2;
            const centerY = height / 2;
            const hopRadius = Math.min(width, height) * 0.08;

            topology.nodes.forEach((node, i) => {
                const hopDistance = node.hop_distance || 0;
                
                if (node.x !== undefined && node.y !== undefined && node.fixed) {
                    node.fx = node.x;
                    node.fy = node.y;
                } else if (hopDistance === 0) {
                    node.x = centerX;
                    node.y = centerY;
                    if (node.device_type === 'local_machine') {
                        node.fx = centerX;
                        node.fy = centerY;
                    }
                } else {
                    const radius = hopDistance * hopRadius;
                    const nodesAtThisHop = topology.nodes.filter(n => n.hop_distance === hopDistance);
                    const nodeIndex = nodesAtThisHop.indexOf(node);
                    const totalAtHop = nodesAtThisHop.length;
                    
                    if (totalAtHop === 1) {
                        if (node.device_type === 'internet') {
                            node.x = centerX;
                            node.y = centerY - radius;
                        } else {
                            node.x = centerX + radius;
                            node.y = centerY;
                        }
                    } else {
                        const angle = (2 * Math.PI * nodeIndex) / totalAtHop;
                        node.x = centerX + radius * Math.cos(angle);
                        node.y = centerY + radius * Math.sin(angle);
                    }
                }
            });

            simulation = d3.forceSimulation(topology.nodes)
                .force("link", d3.forceLink(topology.links).id(d => d.id).distance(d => {
                    const sourceHop = d.source.hop_distance || 0;
                    const targetHop = d.target.hop_distance || 0;
                    return Math.abs(targetHop - sourceHop) * hopRadius * 0.8;
                }))
                .force("charge", d3.forceManyBody().strength(d => {
                    if (d.device_type === 'local_machine') return 0;
                    if (d.device_type === 'internet') return -400;
                    if (d.hop_distance <= 1) return -300;
                    return -150;
                }))
                .force("collision", d3.forceCollide(d => getNodeSize(d.device_type) + 8))
                .force("radial", d3.forceRadial(d => {
                    return (d.hop_distance || 0) * hopRadius;
                }, centerX, centerY).strength(0.3))
                .alpha(0.3);

            const links = g.append("g")
                .selectAll("path")
                .data(topology.links)
                .enter().append("path")
                .attr("class", d => {
                    let classes = `link ${d.type}`;
                    if (d.current_scan) classes += ' current-scan';
                    return classes;
                })
                .style("stroke-width", d => {
                    if (d.type === 'internet_path') return 3;
                    if (d.type === 'traced_path') return 2.5;
                    return 2;
                });

            const nodes = g.append("g")
                .selectAll("g")
                .data(topology.nodes)
                .enter().append("g")
                .attr("class", d => {
                    let classes = "node";
                    if (d.new) classes += " new-discovery";
                    else if (d.current_scan) classes += " current-scan";
                    else if (d.discovered && !d.current_scan) classes += " inactive-host";
                    return classes;
                })
                .attr("id", d => `node-${d.id.replace(/[^a-zA-Z0-9]/g, '-')}`)
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            nodes.append("circle")
                .attr("r", d => getNodeSize(d.device_type))
                .style("fill", d => getCumulativeNodeColor(d.device_type, d.hop_distance, d.new, d.current_scan))
                .style("stroke", d => {
                    if (d.device_type === 'local_machine') return "#00ff00";
                    if (d.new) return "#2ecc71";
                    if (d.current_scan) return "#e94560";
                    if (d.discovered) return "#fff";
                    return "#999";
                })
                .style("stroke-width", d => {
                    if (d.device_type === 'local_machine') return 4;
                    if (d.new) return 4;
                    if (d.current_scan) return 3;
                    return d.discovered ? 2 : 2;
                })
                .style("stroke-dasharray", d => {
                    if (d.discovered && !d.current_scan && !d.new) return "4,2";
                    return "none";
                });

            nodes.append("text")
                .attr("text-anchor", "middle")
                .attr("dy", 5)
                .style("font-size", d => Math.min(getNodeSize(d.device_type) * 0.8, 18) + "px")
                .style("pointer-events", "none")
                .text(d => getDeviceIcon(d.device_type));

            nodes.filter(d => d.hop_distance > 0)
                .append("text")
                .attr("class", "hop-label")
                .attr("dy", d => -getNodeSize(d.device_type) - 8)
                .text(d => `H${d.hop_distance}`);

            nodes.filter(d => d.new)
                .append("text")
                .attr("text-anchor", "middle")
                .attr("dy", d => -getNodeSize(d.device_type) - 22)
                .style("font-size", "8px")
                .style("fill", "#2ecc71")
                .style("font-weight", "bold")
                .text("NEW");

            nodes.filter(d => d.scan_count > 1)
                .append("text")
                .attr("text-anchor", "middle")
                .attr("dx", d => getNodeSize(d.device_type) + 8)
                .attr("dy", -5)
                .style("font-size", "8px")
                .style("fill", "#f39c12")
                .style("font-weight", "bold")
                .text(d => `Ã—${d.scan_count}`);

            nodes.append("text")
                .attr("class", "node-label")
                .attr("dy", d => getNodeSize(d.device_type) + 18)
                .text(d => {
                    if (d.device_type === 'wildcard') return '* timeout';
                    if (d.device_type === 'internet') return 'Internet';
                    if (d.device_type === 'local_machine') return 'You';
                    if (d.ip === '*') return '*';
                    return d.ip.split('.').pop();
                });

            nodes.filter(d => d.hostname !== d.ip && d.device_type !== 'wildcard' && d.hostname.length < 20)
                .append("text")
                .attr("class", "node-label")
                .attr("dy", d => getNodeSize(d.device_type) + 32)
                .style("font-size", "9px")
                .style("fill", "#ccc")
                .text(d => d.hostname.length > 15 ? d.hostname.substring(0, 15) + "..." : d.hostname);

            const tooltip = d3.select("#tooltip");
            
            nodes
                .on("mouseover", (event, d) => {
                    let content = `<div class="tooltip-header">${d.hostname}</div>`;
                    
                    content += `<div class="tooltip-row">
                        <span class="tooltip-label">IP:</span>
                        <span class="tooltip-value">${d.ip}</span>
                    </div>`;
                    
                    content += `<div class="tooltip-row">
                        <span class="tooltip-label">Type:</span>
                        <span class="tooltip-value">${d.device_type}</span>
                    </div>`;
                    
                    content += `<div class="tooltip-row">
                        <span class="tooltip-label">Hop Distance:</span>
                        <span class="tooltip-value">${d.hop_distance || 0}</span>
                    </div>`;
                    
                    if (d.scan_count) {
                        content += `<div class="tooltip-row">
                            <span class="tooltip-label">Scan Count:</span>
                            <span class="tooltip-value">${d.scan_count}</span>
                        </div>`;
                    }
                    
                    let status = 'Intermediate hop';
                    if (d.discovered) {
                        if (d.new) status = '<span style="color: #2ecc71">New discovery</span>';
                        else if (d.current_scan) status = '<span style="color: #e94560">Current scan</span>';
                        else status = '<span style="color: #666">Previous scan</span>';
                    }
                    
                    content += `<div class="tooltip-row">
                        <span class="tooltip-label">Status:</span>
                        <span class="tooltip-value">${status}</span>
                    </div>`;
                    
                    if (d.mac) content += `<div class="tooltip-row">
                        <span class="tooltip-label">MAC:</span>
                        <span class="tooltip-value">${d.mac}</span>
                    </div>`;
                    
                    if (d.rtt) content += `<div class="tooltip-row">
                        <span class="tooltip-label">RTT:</span>
                        <span class="tooltip-value">${d.rtt}ms</span>
                    </div>`;
                    
                    tooltip.transition().duration(200).style("opacity", 1);
                    tooltip.html(content)
                        .style("left", (event.pageX + 15) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(300).style("opacity", 0);
                });

            simulation.on("tick", () => {
                topology.nodes.forEach(d => {
                    if (d.device_type === 'local_machine') {
                        d.x = centerX;
                        d.y = centerY;
                    }
                });

                links.attr("d", d => {
                    return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                });

                nodes.attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }

        function getNodeSize(type) {
            const sizes = {
                'router': 25,
                'gateway': 30,
                'switch': 20,
                'ap': 18,
                'host': 15,
                'local_machine': 35,
                'intermediate': 18,
                'wildcard': 12,
                'internet': 40
            };
            return sizes[type] || 15;
        }

        function getCumulativeNodeColor(type, hopDistance, isNew, isCurrentScan) {
            const baseColors = {
                'router': '#e94560',
                'gateway': '#4a90e2',  
                'switch': '#f39c12',
                'ap': '#2ecc71',
                'host': '#9b59b6',
                'local_machine': '#00ff00',
                'intermediate': '#ff8c00',
                'wildcard': '#666666',
                'internet': '#00bfff'
            };
            
            let color = baseColors[type] || '#9b59b6';
            
            if (isNew) {
                color = d3.rgb(color).brighter(0.5).toString();
            } else if (!isCurrentScan && type !== 'local_machine' && type !== 'internet') {
                color = d3.rgb(color).darker(0.5).toString();
            }
            
            if (hopDistance && hopDistance > 2) {
                color = d3.rgb(color).darker(0.2).toString();
            }
            
            return color;
        }

        function focusHost(ip) {
            const nodeId = `node-${ip.replace(/[^a-zA-Z0-9]/g, '-')}`;
            const node = d3.select(`#${nodeId}`);
            if (node.empty()) return;
            
            d3.selectAll('.node circle').style('stroke-width', d => {
                if (d.device_type === 'local_machine') return 4;
                if (d.new) return 4;
                if (d.current_scan) return 3;
                return d.discovered ? 2 : 2;
            });
            
            node.select('circle')
                .style('stroke-width', 8)
                .style('stroke', '#fff');
            
            d3.selectAll('.link')
                .style('opacity', d => {
                    if (d.source.id === ip || d.target.id === ip) return 1;
                    return 0.2;
                });
            
            const pathNodes = new Set();
            topology.links.forEach(link => {
                if (link.target.id === ip) {
                    pathNodes.add(link.source.id);
                    pathNodes.add(link.target.id);
                }
            });
            
            d3.selectAll('.node circle')
                .style('opacity', d => pathNodes.has(d.id) ? 1 : 0.4);

            const nodeData = topology.nodes.find(n => n.id === ip);
            if (nodeData && svg) {
                const transform = d3.zoomTransform(svg.node());
                const x = -nodeData.x * transform.k + svg.node().getBoundingClientRect().width / 2;
                const y = -nodeData.y * transform.k + svg.node().getBoundingClientRect().height / 2;
                
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity.translate(x, y).scale(transform.k)
                );
            }
        }

        function resetView() {
            if (topology.nodes.length > 0) {
                drawCumulativeTopology();
            }
            
            d3.selectAll('.link').style('opacity', 1);
            d3.selectAll('.node circle').style('opacity', 1);
        }

        function clearTopology() {
            if (svg) {
                svg.selectAll("*").remove();
            }
            if (simulation) {
                simulation.stop();
            }
        }

        function dragstarted(event, d) {
            if (d.device_type === 'local_machine') return;
            if (!event.active) simulation.alphaTarget(0.1).restart();
            d.fx = d.x;
            d.fy = d.y;
            
            d3.select(this).classed("dragging", true);
        }

        function dragged(event, d) {
            if (d.device_type === 'local_machine') return;
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (d.device_type === 'local_machine') return;
            if (!event.active) simulation.alphaTarget(0);
            
            if (socket) {
                socket.emit('save_node_position', {
                    ip: d.id,
                    x: d.fx,
                    y: d.fy,
                    fixed: true
                });
            }
            
            d3.select(this).classed("dragging", false);
        }

        document.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && event.ctrlKey) {
                toggleScan();
            }
            if (event.key === 'Escape' && isScanning) {
                socket.emit('stop_scan');
            }
            if (event.key === 'r' && event.ctrlKey) {
                resetView();
                event.preventDefault();
            }
            if (event.key === 'Delete' && event.ctrlKey && event.shiftKey) {
                clearCumulativeData();
                event.preventDefault();
            }
            if (event.key === '+' && event.ctrlKey) {
                zoomIn();
                event.preventDefault();
            }
            if (event.key === '-' && event.ctrlKey) {
                zoomOut();
                event.preventDefault();
            }
            if (event.key === '0' && event.ctrlKey) {
                zoomReset();
                event.preventDefault();
            }
            if (event.key === 't' && event.ctrlKey) {
                toggleTraffic();
                event.preventDefault();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            initConnection();
            
            document.getElementById('network-input').focus();
            
            window.addEventListener('resize', () => {
                if (topology.nodes.length > 0) {
                    setTimeout(drawCumulativeTopology, 100);
                }
            });
            
            const topologyContainer = document.querySelector('.topology-container');
            topologyContainer.addEventListener('wheel', (event) => {
                if (event.ctrlKey) {
                    event.preventDefault();
                    if (svg && zoom) {
                        const direction = event.deltaY > 0 ? -1 : 1;
                        const scaleFactor = direction > 0 ? 1.1 : 0.9;
                        zoom.scaleBy(svg, scaleFactor);
                    }
                }
            });
        });
    </script>
</body>
</html>
